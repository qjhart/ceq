/// <reference types="jest" />

import "../src/Math_polyfill";
import * as _ from "lodash";
import {Int} from "../src/Int";
import {POT} from "../src/POT";
import {CEQ} from "../src/CEQ";

test('Parse Errors', () => {
  let t={
    'X':'ParseError',
    'q:X':'ParseError',
    'q:0X':'ParseError',
    'q:0.A':'ParseError',
    'q:2.4':'ParseError',
  };

  for (let k in t) {
    expect(()=>{CEQ.parse(k)}).toThrow(Error);
    expect(CEQ.isvalid(k)).toBe(false);
  }
});


test("prefix parse test", () => {
  let parts=['ceq','quad']
  let t={
    'q:0':['q:0',[ 1, 1]],
    'q:1':['q:1',[ 1,-1]],
    'q:2':['q:2',[-1, 1]],
    'q:3':['q:3',[-1,-1]],
    '7':['7',[0,0]],
    'E':['e',[0,0]],
    'f':['f',[0,0]],
  }
  for (let k in t) {
    expect(CEQ.isvalid(k)).toBe(true);
    expect(_.values(_.pick(CEQ.parse(k),parts))).toStrictEqual(t[k]);
  }
});

test("b4 parse test", () => {
  let parts=['ceq','b4'];
  let t={
    '0.0':['0.0','0'],
    ':1.0':[':1.0','0'],
    'CEQ:2.1':['CEQ:2.1','1'],
    'q:2.2':['q:2.2','2'],
    'q:2.3':['q:2.3','3'],
    'q:2.33':['q:2f',''],
    'q:0.111':['q:05.1','1'],
    '3.110':['35.0','0'],
    '2.33333333':['2ffff',''],
    '3.3322110':['3fa5.0','0'],
  }
  for (let k in t) {
    expect(_.values(_.pick(CEQ.parse(k),parts))).toStrictEqual(t[k]);
  }
});

test("axis test", () => {
  let t={
    '0':['8','8'],
    '0.0':['8.0','8.0'],
    '0.1':['8.1','8.0'],
    '0.2':['8.0','8.2'],
    '0.3':['8.1','8.2'],
    '00':['80','80'],
    '01':['81','80'],
    '02':['80','82'],
    '03':['81','82'],
    '04':['84','80'],
    '05':['85','80'],
    '06':['84','82'],
    '07':['85','82'],
    '08':['80','88'],
    '09':['81','88'],
    '0A':['80','8a'],
    '0B':['81','8a'],
    '0C':['84','88'],
    '0D':['85','88'],
    '0E':['84','8a'],
    '0F':['85','8a'],

  };
  for (let k in t) {
    expect(CEQ.axis(k)).toStrictEqual(t[k]);
  }
});

test("bounds test", () => {
  let t={
    '7':[[-1024,1024],[-1024,1024]],
    '0':[[0,1024],[0,1024]],
    '1':[[0,1024],[-0,-1024]],
    '2':[[-0,-1024],[0,1024]],
    '3':[[-0,-1024],[-0,-1024]],
    '0.0':[[0,512],[0,512]],
    '0.1':[[512,1024],[0,512]],
    '0.2':[[0,512],[512,1024]],
    '0.3':[[512,1024],[512,1024]],
    '00':[[0,256],[0,256]],
    '01':[[256,512],[0,256]],
    '04':[[512,768],[0,256]],
    '05':[[768,1024],[0,256]],
    '02':[[0,256],[256,512]],
    '03':[[256,512],[256,512]],
    '06':[[512,768],[256,512]],
    '07':[[768,1024],[256,512]],
    '08':[[0,256],[512,768]],
    '09':[[256,512],[512,768]],
    '0c':[[512,768],[512,768]],
    '0d':[[768,1024],[512,768]],
    '0a':[[0,256],[768,1024]],
    '0b':[[256,512],[768,1024]],
    '0e':[[512,768],[768,1024]],
    '0f':[[768,1024],[768,1024]],
    '000002':[[0,1],[1,2]],
    '0fffff':[[1023,1024],[1023,1024]],
    '1fffff':[[1023,1024],[-1023,-1024]],

  };
  for (let k in t) {
    expect(CEQ.bounds(k)).toStrictEqual(t[k]);
  }
});

test("Option tests", () =>{
  expect(CEQ.center_to_ceq([256,256])).toBe('0.0');
  expect(()=>{CEQ.center_to_ceq([256,256],{min:1024 as POT})}).toThrow(Error);
});


test("center_to_ceq tests", () =>{
  let t2 : Array <[string,[number,number]]> = [
    ['0.1',[768,256]],
    ['0',[512,512]],
    ['0.0',[256,256]],
    ['f',[512,1025]],
    ['7',[0,0]],
    ['0',[512,512]],
    ['1',[512,-512]],
    ['2',[-512,512]],
    ['3',[-512,-512]],
    ['0.0',[256,256]],
    ['0.1',[768,256]],
    ['0.2',[256,768]],
    ['0.3',[768,768]],
    ['3.0',[-256,-256]],
    ['3.1',[-768,-256]],
    ['3.2',[-256,-768]],
    ['3.3',[-768,-768]],
    ['000002',[0.5,1.5]],
    ['0fffff',[1023.5,1023.5]],
    ['1fffff',[1023.5,-1023.5]],
  ];
  t2.forEach((t)=> { expect(CEQ.center_to_ceq(t[1])).toBe(t[0])});
});
